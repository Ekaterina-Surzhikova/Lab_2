# Суржикова Екатерина ИТ-14. Лабораторная работа №2. Вариант 5.
## Задание 1
### Задача 1
Точка координат. Создайте сущность Точка, расположенную на двумерной плоскости, которая описывается: • Координата Х: число • Координата Y: число • Может возвращать текстовое представление вида “{X;Y}” Необходимо создать три точки с разными координатами и вывести на экран их текстовое представление.

Алгоритм решения
В классе Point объявлены приватные поля x и y целочисленного типа. Реализованы свойства: геттеры (getX(), getY()) для доступа к координатам и сеттеры (setX(), setY()) для их изменения.
Класс содержит два конструктора:
Конструктор по умолчанию создает точку с координатами (0, 0)
Конструктор с параметрами принимает значения x и y
Метод toString() возвращает строковое представление в формате "{X;Y}". Дополнительные методы printInfo() и display() обеспечивают вывод информации о точке.
В основной программе создаются три точки с координатами (2,3), (-1,4), (0,-5) и выводятся их текстовые представления.

Тестирование
Входные данные:

Point(2, 3)

Point(-1, 4)

Point(0, -5)

Вывод:
--- ВСЕ ТОЧКИ ---
1. {2;3}
2. {-1;4}
3. {0;-5}
### Задача 3
Имена. Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя, Отчество. Имя может быть приведено к строковому виду, включающему традиционное представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван Иванович”). Необходимо предусмотреть возможность того, что какой-либо из параметров может быть не задан, и в этом случае он не учитывается при приведении к текстовому виду. Необходимо создать следующие имена: • Клеопатра • Пушкин Александр Сергеевич • Маяковский Владимир Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в образовании строки.

Алгоритм решения
Класс Name содержит поля lastName, firstName, middleName строкового типа. Конструктор принимает три параметра, допускающие значение null.
Метод toString() реализует интеллектуальное формирование строки:
Проверяет каждое поле на null и пустоту
Добавляет только непустые значения в результирующую строку
Разделяет компоненты пробелами
В основной программе создаются три имени согласно требованиям задачи.

Тестирование
Входные данные:

Name(null, "Клеопатра", null)

Name("Пушкин", "Александр", "Сергеевич")

Name("Маяковский", "Владимир", null)

Вывод:
--- ВСЕ ИМЕНА ---
1. Клеопатра
2. Пушкин Александр Сергеевич
3. Маяковский Владимир
## Задание 2
### Задача 1
Прямая. Создайте сущность Линия, расположенную на двумерной плоскости, которая описывается: • Координата начала: Точка • Координата конца: Точка • Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}” Для указания координат нужно использовать сущность Точка, разработанную в задании 1.1. Создайте линии со следующими характеристиками: 1. Линия 1 с началом в т. {1;3} и концом в т.{23;8}. 2. Линия 2, горизонтальная, на высоте 10, от точки 5 до точки 25. 3. Линия 3, которая начинается всегда там же, где начинается линия 1, и заканчивается всегда там же, где заканчивается линия 2. Таким образом, если положение первой или второй линии меняется, то меняется и третья линия. 4. После создания всех трех объектов измените координаты первой и второй линий, причем сделайте это таким образом, чтобы положение третьей линии соответствовало требованиям пункта 3. 5. Измените координаты первой линии так, чтобы при этом не изменились, координаты третьей линии.

Алгоритм решения
Класс Line содержит поля start и end типа Point. Метод getTextRepresentation() возвращает строку в требуемом формате.
Ключевая особенность - использование ссылок для линии 3.
Это обеспечивает автоматическое обновление линии 3 при изменении точек линий 1 и 2.

Тестирование
Демонстрация работы:
=== ИСХОДНЫЕ ЛИНИИ ===
Линия 1: Линия от {1;3} до {23;8}
Линия 2: Линия от {5;10} до {25;10}
Линия 3: Линия от {1;3} до {25;10}

После изменения:
Линия 1: Линия от {10;15} до {23;8}
Линия 2: Линия от {5;10} до {30;20}
Линия 3: Линия от {10;15} до {30;20}
## Задание 3
### Задача 3
Города. Создайте сущность Город, которая будет представлять собой точку на карте со следующими характеристиками: • Название города • Набор путей к следующим городам, где путь представляет собой сочетание Города и стоимости поездки в него. Кроме того, Город может возвращать текстовое представление, в виде названия города и списка связанных с ним городов (в виде пары: “название:стоимость”). Используя разработанную сущность реализуйте схему, представленную на рисунке 2. Рис. 2. Города и пути между ними.

Алгоритм решения
Реализована система из трех классов:
Класс City:
Поля: name (String), routes (Map<City, Integer>)
Методы управления маршрутами: addRoute(), removeRoute()
Методы проверки: hasRouteTo(), getRouteCost()

Тестирование
Входные данные: Построение демонстрационной сети городов
Вывод: 
Город: Москва
  Связанные города:
    - Санкт-Петербург: 500
    - Казань: 800
    - Нижний Новгород: 400
## Задание 4
### Задача 8
Создаем Города. Измените сущность Город из задачи 3.3. Новые требования включают: • Город можно создать указав только название • Город можно создать указав название и набор связанных с ним городов и стоимостей путей к ним

Алгоритм решения
Класс CityManager:
Централизованное управление городами
Методы создания городов: createCity(name), createCity(name, routes)
Метод создания двусторонних связей: createBidirectionalRoute()
Построение сложных сетей: buildSampleNetwork()

Тестирование
Запрос о выводе демонстрации
Вывод:
=== ДЕМОНСТРАЦИЯ КЛАССА ГОРОД ===
Демонстрация работы CityManager с разными способами создания городов:

=== ВСЕ ГОРОДА В СЕТИ ===
Город: Казань
Связанные города:
  - Москва: 800
-----------------------------
Город: Москва
Связанные города:
  - Казань: 800
  - Нижний Новгород: 400
-----------------------------
Город: Санкт-Петербург
Связанные города:
  - Москва: 500
-----------------------------
Город: Нижний Новгород
Связанные города:
  - Москва: 400
-----------------------------

## Задание 5
### Задача 5
Дроби. Создайте сущность Дробь со следующими особенностями: • Имеет числитель: целое число • Имеет знаменатель: целое число • Дробь может быть создана с указанием числителя и знаменателя • Может вернуть строковое представление вида “числитель/знаменатель” • Может выполнять операции сложения, вычитания, умножения и деления с другой Дробью или целым числом. Результатом операции должна быть новая Дробь (таким образом,обе исходные дроби не изменяются) Затем необходимо выполнить следующие задачи: 1. Создать несколько экземпляров дробей. 2. Написать по одному примеру использования каждого метода. 3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9» 4. Посчитать f1.sum(f2).div(f3).minus(5)

Алгоритм решения
Класс Fraction содержит:
Автоматическое упрощение дробей в методе simplify()
Вычисление НОД алгоритмом Евклида в методе gcd()
Математические операции: sum(), minus(), multiply(), div()
Перегруженные версии методов для работы с целыми числами
Контроль ошибок (деление на ноль)

Тестирование
Входные данные:

f1 = 1/3, f2 = 2/3, f3 = 1/2

Вычисление: f1.sum(f2).div(f3).minus(5)

Вывод:
Исходные дроби:
f1 = 1/3
f2 = 2/3
f3 = 1/2

Пример цепочки операций: ((1/3 + 2/3) ÷ 1/2) - 5
Результат: -3/1
